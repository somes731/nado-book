\newpage
## Utreexo {#sec:utreexo}

\EpisodeQR{15}

Всякий раз, когда выполняется новая биткоин-транзакция, биткоин-узлы используют набор UTXO, чтобы определить, что потраченные монеты действительно существуют (см. главу @sec:assume). Этот набор UTXO в настоящее время имеет размер в несколько гигабайт, продолжает расти с течением времени, и нет верхнего предела того, насколько большим он может стать.

Поскольку биткоин-узлы работают лучше всего, если набор UTXO хранится в оперативной памяти, а оперативная память для компьютеров остается относительно дефицитным ресурсом, для производительности узла было бы полезно, если бы набор UTXO можно было хранить в более компактном формате. Это обещает сделать Utreexo.^[Произносится как U Tree X O. См. также: <https://bitcoinmagazine.com/articles/bitcoins-growing-utxo-problem-and-how-utreexo-can-help-solve-it>]

В рамках Utreexo все существующие UTXO включаются их в дерево Меркла, которое представляет собой структуру данных, состоящую только из хэшей. В этой главе объясняется, как при совершении новой транзакции компактной структуры Utreexo может быть достаточно для доказательства того, что в ней присутствует конкретный UTXO. В главе также рассматриваются потенциальные преимущества, которые могут появиться при использовании этого решения, а также некоторые потенциальные компромиссы.


### Проблема

При синхронизации нового биткоин-узла одной из проблем является объем оперативной памяти (ОЗУ), который у вас есть. В обычной работе вам не нужно иметь на своем компьютере много оперативной памяти, но если вы хотите синхронизироваться быстро, она вам потребуется.

Причина, по которой это необходимо - набор UTXO, который представляет собой список всех существующих монет, включая те, которыми вы владеете. Каждый раз, когда приходит новый блок, для каждой транзакции в нем вы проверяете, тратит ли он реально существующие монеты. Вы также помните, какие новые монеты были созданы транзакцией, чтобы знать об этом, когда они будут потрачены в следующем блоке. Эта информация хранится в базе данных, и если она находится на вашем жестком диске, ее проверка и обновление — медленный процесс. Однако, если база данных находится в вашей оперативной памяти, все работает быстро.

Время, затрачиваемое на это, может быть различным, но, скажем, у вас есть относительно новый MacBook Pro с 32 ГБ ОЗУ, и вы позволили узлу использовать половину этого объема; для синхронизации всей цепи потребуется около семи часов. ^ [В конце 2020 года бывший разработчик Bitcoin Core Йонас Шнелли синхронизировал цепочку на Apple M1 за пять часов. Было бы быстрее, если бы он выделил более 5 ГБ оперативной памяти (используя `-dbcache`). Тем временем сеть выросла, отсюда и более консервативная оценка. <https://twitter.com/_jonasschnelli_/status/1333303029370675201>] Однако, допустим, у вас есть Raspberry Pi только с 2 ГБ ОЗУ и небольшим жестким диском. В этом случае процесс может занять несколько недель.^[Есть два узких места. Во-первых, ваша нода сохраняет как можно больше в оперативной памяти во время синхронизации, но как только она заполняет эту память, она должна записать базу данных UTXO на диск, очистить свою память и снова начать кэширование. Вторая проблема заключается в том, что если блокчейн не помещается на жесткий диск, то вашей ноде приходится удалять старые блоки, чтобы освободить место для новых. Побочным эффектом этого оказывается то, что находящаяся в оперативной памяти база данных монет должна быть записана на диск, что еще больше замедляет процесс синхронизации.]

Ключевым моментом здесь является то, что если вы можете хранить больше UTXO в оперативной памяти, вы будете синхронизироваться быстрее. Было бы неплохо, если бы размер набора UTXO можно было уменьшить, но это не всегда возможно. Конечно, если вы тратите больше монет, чем создаете, то количество UTXO и использование оперативной памяти уменьшаются. Однако в наборе UTXO много мусора, потому что в прошлом люди создавали фальшивые транзакции на адреса с мультиподписью, чтобы, например, поместить фотографии Обамы в блокчейн. И все это хранится в вашей оперативной памяти, потому что ваш узел понятия не имеет, что в них нет смысла.

Однако, если мы ожидаем, что все в мире в конечном итоге будут использовать Биткоин и будут иметь по крайней мере один или два UTXO на каждого, это потребует терабайтов оперативной памяти, и закон Мура^[<https://en.wikipedia.org/wiki/Moore %27s_law>] в ближайшее время не позволит за этим угнаться. Но даже если далеко не весь мир использует Биткоин, все может прийти к тому, что все меньше и меньше людей будет иметь достаточно оперативной памяти для быстрой синхронизации, и это проблема. Если меньше людей управляют собственным узлом, система становится менее децентрализованной.

### Utreexo

Один из способов решения этой проблемы - предложение Таджа Дрийи, Utreexo.^[<https://dci.mit.edu/utreexo>, <https://www.youtube.com/watch?v=6Y6n88DmkjU>] Дрийя — научный сотрудник Digital Currency Initiative Массачусетского технологического института.

Сегодня, имея дело с Биткоином, вы можете сократить архивное хранилище блоков, чтобы сэкономить место на диске. После того, как ваш узел загрузит блок, обработает его и обновит набор UTXO, он больше не будет использовать этот блок. Ваш узел точно знает, какие монеты существуют в наборе UTXO, и это вся информация, необходимая для проверки будущих транзакций.

Когда у узла включен режим pruning (обрезки), он удерживает блок еще несколько дней, а затем удаляет его. Таким образом, вам потребуется менее гигабайта места, хотя сам блокчейн занимает сотни гигабайт. Недостаток состоит в том, что вы не храните блоки, поэтому вы не можете поделиться ими с другими узлами. Это допустимо, если у достаточного количества других узлов есть полный архив.

В рамках Utreexo вы обрезаете и набор UTXO. Вместо того, чтобы выбрасывать транзакции (вместе с блоками, в которых они находятся), вы выбрасываете список существующих монет. Единственное, что вы сохраняете — это корень Меркла, то есть хэш, представляющий все существующие монеты. Каждый лист дерева Меркла представляет собой один UTXO, и корень Меркла связывает их все. Для каждой монеты, которая вам небезразлична, поскольку, например, находится в вашем собственном кошельке, ваш узел хранит доказательство Меркла. Когда вы тратите монету, вам необходимо приложить это доказательство к своей транзакции, чтобы другие узлы могли убедиться, что монета существует.

Иными словами, обычно, когда кто-то отправляет вам транзакцию, транзакция говорит: «Я трачу эти монеты на входе, и вы, человек, управляющий узлом, несете ответственность за проверку существования этих входов в вашей собственной базе данных. ” А теперь вы переворачиваете ситуацию и говорите другому узлу: «Я понятия не имею, какие монеты существуют, потому что у меня недостаточно оперативной памяти, чтобы отслеживать все это. Вы сами должны доказать мне, что эта монета действительно существовала». Таким образом, бремя доказывания перекладывается на отправителя, и осталось только понять, как это сделать.

\newpage
### Краткое введение в доказательство Меркла

![Дерево Меркла. Чтобы доказать существование Монеты 3, вам необходимо предоставить доказательство Меркла, состоящее из трех отмеченных элементов.^[Приводится с изменениями из: <https://commons.wikimedia.org/wiki/File:Hash_Tree.svg>]](resources/tree.svg)

На рисунке выше показано, как вы можете доказать существование Монеты 3, используя доказательство Меркла, при наличии верификатора, который знает только корень Меркла (вверху). Во-первых, вы раскрываете саму монету, которая представляет собой просто выход транзакции с суммой и `scriptPubKey`. Верификатор хеширует полученное и получает Хэш 1-0 (прямо над Монетой 3 на рисунке). Затем вы предоставляете Хэш 1-1. Даже если вы, возможно, не владеете Монетой 4 и можете даже не знать ее количество и `scriptPubKey`, вы все же знаете ее хеш, потому что ваш кошелек отслеживал эту информацию. При этом верификатор может вычислить Хэш 1. Затем вы предоставляете Хэш 0, и теперь верификатор может увидеть, что ваше доказательство приводит к тому же корневому хэшу Меркла, который ему уже известен. Так вы продемонстрировали право собственности на Монету 3 без необходимости для верификатора знать весь набор UTXO.

Мы вернемся к деревьям Меркла в главе @sec:miniscript и главе @sec:taproot_basics.

### Увидеть лес за деревьями

Сейчас, если кто-то отправляет вам транзакцию, вы проверяете свой узел и базу данных с набором UTXO, чтобы убедиться, что транзакция тратит действительные UTXO. С опцией Utreexo уже отправитель должен будет предоставить вам доказательство того, что его транзакция тратит существующие UTXO. Хотя вам больше не нужно хранить несколько гигабайт данных UTXO, вам все равно нужно отслеживать несколько вещей, а именно дерево хэшей Меркла — или несколько таких деревьев.

Все существующие UTXO будут помещены в это дерево, и каждый может построить это дерево, если воспроизведет весь блокчейн. Дерево строится следующим образом. У вас есть первый и второй UTXO рядом друг с другом. Затем вы берете хэш этих двух объединенных UTXO. Вы можете сделать это снова для еще двух существующих UTXO и получить их объединенный хэш. Например, у вас есть всего четыре UTXO. Они объединяются по два, а затем полученные два объединяются снова, и в итоге вы получаете один хэш.

Utreexo использует совершенные деревья, что означает, что количество листьев в каждом должно быть степенью двойки. Поскольку набор UTXO содержит произвольное количество монет, в итоге вы получите лес деревьев. Например, если есть шесть монет, в вашем лесу будет дерево с 2 ^ 2 = 4 листьями и дерево с двумя листьями. Все, что нужно хранить вашему узлу, — это корневой хэш Меркла для каждого дерева. В настоящее время существует чуть менее 100 миллионов UTXO.^[<https://txstats.com/dashboard/db/utxo-set-repartition-by-output-type>] Поскольку это меньше 2^27, то чтобы представить их все, потребуется 27 деревьев. Каждый хэш SHA-256^[<https://qvault.io/cryptography/how-sha-2-works-step-by-step-sha-256/>] составляет 32 байта, поэтому ваш узел должен хранить 27 * 32 = 864 байта. Даже если каждый человек будет владеть несколькими монетами, необходимый объем вырастет всего лишь примерно до одного килобайта.

Как мы обновляем дерево для каждого блока по мере удаления и добавления листьев, то есть траты и создания UTXO? В сущности, вы убрать взять потраченный UTXO из дерева и поместить туда новый. Для этого вам нужно пересчитать дерево, и это делается, зная соседние UTXO. Мы уже продемонстрировали, как доказать, что нечто содержится в дереве, и это, в сущности, именно та информация, которая вам нужна, чтобы поместить что-то еще в конец дерева, а затем получить корневой хэш.

Когда вы синхронизируете блокчейн, вы можете проследить все дерево, но тогда вам потребуется много оперативной памяти, как и в исходном сценарии. Вот почему вы сохраняете только корень каждого дерева. Затем, когда у кого-то есть новая транзакция, которую вы хотите проверить, он должен предоставить вам доказательства Меркла для всех входов, которые тратятся, чтобы доказать, что они существуют. Эти доказательства покажут вам вам, какие у предстоящей транзакции есть выходы — далее выходы будут подставлены в деревья вместо входов. Также они расскажут вам о любых новых создающихся деревьях.

### Мосты

Есть два способа узнать о транзакции. Кто-то может отправить вам ее по сети, и в этом случае вы добавите ее в свой мемпул. Или она может быть частью полученного вами блока.

Как бы вы проверили транзакцию в первом сценарии? В режиме Utreexo у вас в оперативной памяти есть вершина деревьев. Отправитель отвечает за отправку транзакции, а также за подтверждение того, что транзакция действительна, что также означает необходимость проинформировать вас, как найти эту транзакцию в лесу. Если отправитель не поддерживает Utreexo и не предоставляет доказательства, ваш узел может просто проигнорировать транзакцию.

Но что насчет второго сценария? Если майнер добывает блок, и в нем находится транзакция, то блок не содержит доказательства. Чтобы получить это доказательство, вам нужна помощь какого-нибудь промежуточного узла, выполняющего роль моста. Это узел, у которого есть набор UTXO, добытый старомодным способом, поскольку у него много оперативной памяти или он просто медленный. И он производит все эти доказательства и рассылает их всем, кому они нужны.

Когда мост получает транзакцию, не имеющую доказательства Меркла, он берет имеющееся у него доказательство, прикрепляет его к транзакции и отправляет другим узлам Utreexo. То же самое касается целых блоков. Вам не нужно напрямую подключаться к такому мосту, так как другие узлы, поддерживающие Utreexo, могут ретранслировать блоки с прикрепленными доказательствами. С точки зрения узла Utreexo, мост — это просто узел Utreexo, а с точки зрения устаревших узлов — это просто устаревший узел.

В мостах нет ничего волшебного. Любой узел с исходным набором UTXO может построить доказательство для любой транзакции. Но это лишило бы Utreexo смысла, потому что отслеживание и обычного набора UTXO, и таких доказательств занимает много памяти.

Таким образом, мосты выполняют перевод между классическими узлами, которые держат набор UTXO в памяти, и новыми узлами с поддержкой Utreexo, которым это не нужно. Пока существует хоть один мост, он может поддерживать сеть. Однако для этого требуется, чтобы такие мосты поддерживались людьми с добрыми намерениями. Но эти узлы могут измениться, исчезнуть или потерять мотивацию.

В долгосрочной перспективе, если людям понравится Utreexo, учитывая его преимущества — или даже если им это не понравится, но если набор UTXO станет слишком большим и будет требовать слишком много времени для синхронизации на любом обычном компьютере - тогда можно будет сделать софт-форк, требующий, чтобы все нужные доказательства содержались в блоке. ^[Вы также должны включить хэш доказательств где-то в транзакции coinbase. Как мы объяснили в главе @sec:segwit про SegWit, сами доказательства будут находиться в специальном месте внутри блока, которое старые узлы не видят.] Включение доказательств в блоки гарантирует, что они будут доступны для всех узлов.

Компромисс здесь заключается в том, что для больших блоков требуется больше пропускной способности и места на диске, но используется меньше оперативной памяти. На данный момент пропускная способность, вероятно, является более серьезным ограничением, чем память, поэтому софт-форк вряд ли произойдет, но ситуация может измениться в ближайшие десятилетия.

### Несколько крутых штук

Благодаря этому решению, поскольку вам не потребуется много оперативной памяти, вы можете начать работать на специализированном оборудовании. Например, смартфоны, как правило, имеют очень мало оперативной памяти, поэтому Utreexo может значительно повысить их производительность. Или у вас может быть даже специальный чип — вроде графического процессора — с крошечной встроенной памятью, который проверяет биткоин-блоки. ^[Тогда мы получим протокол, буквально высеченный в камне или, по крайней мере, высеченный в кремнии. Если кто-то захочет провести хард-форк, придется отправить на свалку все оборудование, обеспечивающее работу узлов, а не только все оборудование для майнинга. Так что это хороший дополнительный барьер, чтобы не делать хардфорки. К сожалению, это также делает менее привлекательными софт-форки, поскольку узлы не смогут проверять новые правила, используя аппаратное ускорение, поэтому вашему компьютеру придется замедляться, чтобы проверять все новые правила всякий раз, когда он сталкивается с транзакциями, подпадающими под новые правила.]

Но даже без специализированного оборудования существует возможность ускориться, если большую часть работы по проверке блоков сможет выполнять ЦП. Лес Меркла размером 1 КБ можно легко хранить прямо в кэше процессора. ^[<https://en.wikipedia.org/wiki/CPU_cache>] Это позволяет избежать необходимости пересылать информацию о наборах UTXO между ЦП и ОЗУ. Точно так же, как использование ОЗУ вместо чтения с физического диска ускоряет процесс, так его ускоряет и использование кэша ЦП, позволяющее избежать использования ОЗУ.

В главе @sec:assume мы описали, что исходный код узла содержит хэш, представляющий набор UTXO для заданной высоты блока. Узлу по-прежнему нужно получить этот набор UTXO размером в несколько гигабайт, и он, вероятно, загрузит его от своих пиров. Но в Utreexo набор UTXO настолько мал, что его можно поместить в исходный код, что избавляет от необходимости загружать набор UTXO, соответствующий снимку.

### Парочка компромиссов

Хотя Utreexo это потенциально очень круто, с ним придется идти на некоторые компромиссы. Наиболее очевидный состоит в том, что если вы начнете использовать Utreexo, а затем кто-то найдет лучший аккумулятор, ^ [Аккумулятор - это общий термин для того, что Utreexo использует для учета монет. Это то, что вы можете использовать, чтобы добавить что-то, а в данном случае также и чтобы удалить что-то. Но для этого можно использовать всевозможные математические трюки. Дерево Меркла концептуально очень простое, как мы надеемся проиллюстрировать, но были и другие предложения, такие как аккумулятор RSA. Есть уйма сортов классной криптографической математики, которую вы можете использовать, чтобы, по сути, добавлять те или иные штуки в набор и удалять их из набора. Слишком рано высекать  какой-либо конкретный аккумулятор в камне с помощью софтфорка.] вам придется переключиться на него. Такое переключение легко осуществить в сценарии с мостами — несколько решений могут существовать параллельно, каждое со своими собственными мостами. Но как только доказательства будут добавлены в блоки с помощью софтфорка, обратного пути не будет.

Другой недостаток состоит в том, что прямо сейчас узким местом для Биткоина представляется именно пропускная способность, и Utreexo может даже усугубить ситуацию. По этой причине Utreexo — это скорее вариант, который люди могут выбрать, если в их случае пропускная способность не является проблемой. Однако, если набор UTXO разрастется до такой степени, что станет бременем и начнет замедлять проверку, то это решение может оказаться более привлекательным.
